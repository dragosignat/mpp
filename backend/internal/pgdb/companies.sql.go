// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: companies.sql

package pgdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCompany = `-- name: CreateCompany :one

INSERT INTO companies (name, industry, size, website, contact_person, email, phone, address, owner_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8,
        $9) RETURNING pid, name, industry, size, website, contact_person, email, phone, address, created_at, updated_at
`

type CreateCompanyParams struct {
	Name          string      `json:"name"`
	Industry      pgtype.Text `json:"industry"`
	Size          pgtype.Text `json:"size"`
	Website       pgtype.Text `json:"website"`
	ContactPerson pgtype.Text `json:"contact_person"`
	Email         pgtype.Text `json:"email"`
	Phone         pgtype.Text `json:"phone"`
	Address       []byte      `json:"address"`
	OwnerID       pgtype.Int4 `json:"owner_id"`
}

type CreateCompanyRow struct {
	Pid           pgtype.UUID      `json:"pid"`
	Name          string           `json:"name"`
	Industry      pgtype.Text      `json:"industry"`
	Size          pgtype.Text      `json:"size"`
	Website       pgtype.Text      `json:"website"`
	ContactPerson pgtype.Text      `json:"contact_person"`
	Email         pgtype.Text      `json:"email"`
	Phone         pgtype.Text      `json:"phone"`
	Address       []byte           `json:"address"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
}

// Companies CRUD operations
func (q *Queries) CreateCompany(ctx context.Context, arg CreateCompanyParams) (CreateCompanyRow, error) {
	row := q.db.QueryRow(ctx, createCompany,
		arg.Name,
		arg.Industry,
		arg.Size,
		arg.Website,
		arg.ContactPerson,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.OwnerID,
	)
	var i CreateCompanyRow
	err := row.Scan(
		&i.Pid,
		&i.Name,
		&i.Industry,
		&i.Size,
		&i.Website,
		&i.ContactPerson,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCompany = `-- name: DeleteCompany :exec
DELETE
FROM companies
WHERE pid = $1
  AND owner_id = $2
`

type DeleteCompanyParams struct {
	Pid     pgtype.UUID `json:"pid"`
	OwnerID pgtype.Int4 `json:"owner_id"`
}

func (q *Queries) DeleteCompany(ctx context.Context, arg DeleteCompanyParams) error {
	_, err := q.db.Exec(ctx, deleteCompany, arg.Pid, arg.OwnerID)
	return err
}

const getCompanies = `-- name: GetCompanies :many
SELECT pid, name, industry, size, website, contact_person, email, phone, address, created_at, updated_at
FROM companies
WHERE owner_id = $1
ORDER BY name
    LIMIT $2
OFFSET $3
`

type GetCompaniesParams struct {
	OwnerID pgtype.Int4 `json:"owner_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type GetCompaniesRow struct {
	Pid           pgtype.UUID      `json:"pid"`
	Name          string           `json:"name"`
	Industry      pgtype.Text      `json:"industry"`
	Size          pgtype.Text      `json:"size"`
	Website       pgtype.Text      `json:"website"`
	ContactPerson pgtype.Text      `json:"contact_person"`
	Email         pgtype.Text      `json:"email"`
	Phone         pgtype.Text      `json:"phone"`
	Address       []byte           `json:"address"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetCompanies(ctx context.Context, arg GetCompaniesParams) ([]GetCompaniesRow, error) {
	rows, err := q.db.Query(ctx, getCompanies, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompaniesRow
	for rows.Next() {
		var i GetCompaniesRow
		if err := rows.Scan(
			&i.Pid,
			&i.Name,
			&i.Industry,
			&i.Size,
			&i.Website,
			&i.ContactPerson,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyByID = `-- name: GetCompanyByID :one
SELECT pid, name, industry, size, website, contact_person, email, phone, address, created_at, updated_at
FROM companies
WHERE pid = $1 AND owner_id = $2
`

type GetCompanyByIDParams struct {
	Pid     pgtype.UUID `json:"pid"`
	OwnerID pgtype.Int4 `json:"owner_id"`
}

type GetCompanyByIDRow struct {
	Pid           pgtype.UUID      `json:"pid"`
	Name          string           `json:"name"`
	Industry      pgtype.Text      `json:"industry"`
	Size          pgtype.Text      `json:"size"`
	Website       pgtype.Text      `json:"website"`
	ContactPerson pgtype.Text      `json:"contact_person"`
	Email         pgtype.Text      `json:"email"`
	Phone         pgtype.Text      `json:"phone"`
	Address       []byte           `json:"address"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetCompanyByID(ctx context.Context, arg GetCompanyByIDParams) (GetCompanyByIDRow, error) {
	row := q.db.QueryRow(ctx, getCompanyByID, arg.Pid, arg.OwnerID)
	var i GetCompanyByIDRow
	err := row.Scan(
		&i.Pid,
		&i.Name,
		&i.Industry,
		&i.Size,
		&i.Website,
		&i.ContactPerson,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTotalNumberOfCompanies = `-- name: GetTotalNumberOfCompanies :one
SELECT COUNT(*)
FROM companies
WHERE owner_id = $1
`

func (q *Queries) GetTotalNumberOfCompanies(ctx context.Context, ownerID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalNumberOfCompanies, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const searchCompanies = `-- name: SearchCompanies :many
SELECT pid, name
FROM companies
WHERE name ILIKE $1 AND owner_id = $2
ORDER BY name
    LIMIT $3
`

type SearchCompaniesParams struct {
	Name    string      `json:"name"`
	OwnerID pgtype.Int4 `json:"owner_id"`
	Limit   int32       `json:"limit"`
}

type SearchCompaniesRow struct {
	Pid  pgtype.UUID `json:"pid"`
	Name string      `json:"name"`
}

func (q *Queries) SearchCompanies(ctx context.Context, arg SearchCompaniesParams) ([]SearchCompaniesRow, error) {
	rows, err := q.db.Query(ctx, searchCompanies, arg.Name, arg.OwnerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchCompaniesRow
	for rows.Next() {
		var i SearchCompaniesRow
		if err := rows.Scan(&i.Pid, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCompany = `-- name: UpdateCompany :exec
UPDATE companies
SET name           = $1,
    industry       = $2,
    size           = $3,
    website        = $4,
    contact_person = $5,
    email          = $6,
    phone          = $7,
    address        = $8,
    updated_at     = NOW()
WHERE pid = $9
  AND owner_id = $10
`

type UpdateCompanyParams struct {
	Name          string      `json:"name"`
	Industry      pgtype.Text `json:"industry"`
	Size          pgtype.Text `json:"size"`
	Website       pgtype.Text `json:"website"`
	ContactPerson pgtype.Text `json:"contact_person"`
	Email         pgtype.Text `json:"email"`
	Phone         pgtype.Text `json:"phone"`
	Address       []byte      `json:"address"`
	Pid           pgtype.UUID `json:"pid"`
	OwnerID       pgtype.Int4 `json:"owner_id"`
}

func (q *Queries) UpdateCompany(ctx context.Context, arg UpdateCompanyParams) error {
	_, err := q.db.Exec(ctx, updateCompany,
		arg.Name,
		arg.Industry,
		arg.Size,
		arg.Website,
		arg.ContactPerson,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.Pid,
		arg.OwnerID,
	)
	return err
}
