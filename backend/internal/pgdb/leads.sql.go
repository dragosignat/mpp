// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: leads.sql

package pgdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLead = `-- name: CreateLead :one

INSERT INTO leads (first_name, last_name, email, phone, company_id, position, social_links, birthday, last_contact,
                   first_contact, follow_up, source, notes, lead_status, preferred_contact_method, lead_score, owner_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16,
        $17) RETURNING pid, first_name, last_name, email, phone, company_id, position, social_links, birthday, last_contact, first_contact, follow_up, source, notes, lead_status, preferred_contact_method, lead_score, created_at, updated_at
`

type CreateLeadParams struct {
	FirstName              string           `json:"first_name"`
	LastName               string           `json:"last_name"`
	Email                  pgtype.Text      `json:"email"`
	Phone                  pgtype.Text      `json:"phone"`
	CompanyID              pgtype.Int4      `json:"company_id"`
	Position               pgtype.Text      `json:"position"`
	SocialLinks            []byte           `json:"social_links"`
	Birthday               pgtype.Date      `json:"birthday"`
	LastContact            pgtype.Timestamp `json:"last_contact"`
	FirstContact           pgtype.Timestamp `json:"first_contact"`
	FollowUp               pgtype.Timestamp `json:"follow_up"`
	Source                 pgtype.Text      `json:"source"`
	Notes                  pgtype.Text      `json:"notes"`
	LeadStatus             pgtype.Text      `json:"lead_status"`
	PreferredContactMethod pgtype.Text      `json:"preferred_contact_method"`
	LeadScore              pgtype.Int4      `json:"lead_score"`
	OwnerID                pgtype.Int4      `json:"owner_id"`
}

type CreateLeadRow struct {
	Pid                    pgtype.UUID      `json:"pid"`
	FirstName              string           `json:"first_name"`
	LastName               string           `json:"last_name"`
	Email                  pgtype.Text      `json:"email"`
	Phone                  pgtype.Text      `json:"phone"`
	CompanyID              pgtype.Int4      `json:"company_id"`
	Position               pgtype.Text      `json:"position"`
	SocialLinks            []byte           `json:"social_links"`
	Birthday               pgtype.Date      `json:"birthday"`
	LastContact            pgtype.Timestamp `json:"last_contact"`
	FirstContact           pgtype.Timestamp `json:"first_contact"`
	FollowUp               pgtype.Timestamp `json:"follow_up"`
	Source                 pgtype.Text      `json:"source"`
	Notes                  pgtype.Text      `json:"notes"`
	LeadStatus             pgtype.Text      `json:"lead_status"`
	PreferredContactMethod pgtype.Text      `json:"preferred_contact_method"`
	LeadScore              pgtype.Int4      `json:"lead_score"`
	CreatedAt              pgtype.Timestamp `json:"created_at"`
	UpdatedAt              pgtype.Timestamp `json:"updated_at"`
}

// Leads CRUD operations
func (q *Queries) CreateLead(ctx context.Context, arg CreateLeadParams) (CreateLeadRow, error) {
	row := q.db.QueryRow(ctx, createLead,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.CompanyID,
		arg.Position,
		arg.SocialLinks,
		arg.Birthday,
		arg.LastContact,
		arg.FirstContact,
		arg.FollowUp,
		arg.Source,
		arg.Notes,
		arg.LeadStatus,
		arg.PreferredContactMethod,
		arg.LeadScore,
		arg.OwnerID,
	)
	var i CreateLeadRow
	err := row.Scan(
		&i.Pid,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CompanyID,
		&i.Position,
		&i.SocialLinks,
		&i.Birthday,
		&i.LastContact,
		&i.FirstContact,
		&i.FollowUp,
		&i.Source,
		&i.Notes,
		&i.LeadStatus,
		&i.PreferredContactMethod,
		&i.LeadScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLead = `-- name: DeleteLead :exec
DELETE
FROM leads
WHERE pid = $1
  AND owner_id = $2
`

type DeleteLeadParams struct {
	Pid     pgtype.UUID `json:"pid"`
	OwnerID pgtype.Int4 `json:"owner_id"`
}

func (q *Queries) DeleteLead(ctx context.Context, arg DeleteLeadParams) error {
	_, err := q.db.Exec(ctx, deleteLead, arg.Pid, arg.OwnerID)
	return err
}

const getLeadByID = `-- name: GetLeadByID :one
SELECT id,
       first_name,
       last_name,
       email,
       phone,
       company_id,
       position,
       social_links,
       birthday,
       last_contact,
       first_contact,
       follow_up,
       source,
       notes,
       lead_status,
       preferred_contact_method,
       lead_score,
       created_at,
       updated_at
FROM leads
WHERE pid = $1
  AND owner_id = $2
`

type GetLeadByIDParams struct {
	Pid     pgtype.UUID `json:"pid"`
	OwnerID pgtype.Int4 `json:"owner_id"`
}

type GetLeadByIDRow struct {
	ID                     int32            `json:"id"`
	FirstName              string           `json:"first_name"`
	LastName               string           `json:"last_name"`
	Email                  pgtype.Text      `json:"email"`
	Phone                  pgtype.Text      `json:"phone"`
	CompanyID              pgtype.Int4      `json:"company_id"`
	Position               pgtype.Text      `json:"position"`
	SocialLinks            []byte           `json:"social_links"`
	Birthday               pgtype.Date      `json:"birthday"`
	LastContact            pgtype.Timestamp `json:"last_contact"`
	FirstContact           pgtype.Timestamp `json:"first_contact"`
	FollowUp               pgtype.Timestamp `json:"follow_up"`
	Source                 pgtype.Text      `json:"source"`
	Notes                  pgtype.Text      `json:"notes"`
	LeadStatus             pgtype.Text      `json:"lead_status"`
	PreferredContactMethod pgtype.Text      `json:"preferred_contact_method"`
	LeadScore              pgtype.Int4      `json:"lead_score"`
	CreatedAt              pgtype.Timestamp `json:"created_at"`
	UpdatedAt              pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetLeadByID(ctx context.Context, arg GetLeadByIDParams) (GetLeadByIDRow, error) {
	row := q.db.QueryRow(ctx, getLeadByID, arg.Pid, arg.OwnerID)
	var i GetLeadByIDRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CompanyID,
		&i.Position,
		&i.SocialLinks,
		&i.Birthday,
		&i.LastContact,
		&i.FirstContact,
		&i.FollowUp,
		&i.Source,
		&i.Notes,
		&i.LeadStatus,
		&i.PreferredContactMethod,
		&i.LeadScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeads = `-- name: GetLeads :many
SELECT id,
       first_name,
       last_name,
       email,
       phone,
       company_id,
       position,
       social_links,
       birthday,
       last_contact,
       first_contact,
       follow_up,
       source,
       notes,
       lead_status,
       preferred_contact_method,
       lead_score,
       created_at,
       updated_at
FROM leads
WHERE owner_id = $1
ORDER BY last_contact DESC LIMIT $2
OFFSET $3
`

type GetLeadsParams struct {
	OwnerID pgtype.Int4 `json:"owner_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type GetLeadsRow struct {
	ID                     int32            `json:"id"`
	FirstName              string           `json:"first_name"`
	LastName               string           `json:"last_name"`
	Email                  pgtype.Text      `json:"email"`
	Phone                  pgtype.Text      `json:"phone"`
	CompanyID              pgtype.Int4      `json:"company_id"`
	Position               pgtype.Text      `json:"position"`
	SocialLinks            []byte           `json:"social_links"`
	Birthday               pgtype.Date      `json:"birthday"`
	LastContact            pgtype.Timestamp `json:"last_contact"`
	FirstContact           pgtype.Timestamp `json:"first_contact"`
	FollowUp               pgtype.Timestamp `json:"follow_up"`
	Source                 pgtype.Text      `json:"source"`
	Notes                  pgtype.Text      `json:"notes"`
	LeadStatus             pgtype.Text      `json:"lead_status"`
	PreferredContactMethod pgtype.Text      `json:"preferred_contact_method"`
	LeadScore              pgtype.Int4      `json:"lead_score"`
	CreatedAt              pgtype.Timestamp `json:"created_at"`
	UpdatedAt              pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetLeads(ctx context.Context, arg GetLeadsParams) ([]GetLeadsRow, error) {
	rows, err := q.db.Query(ctx, getLeads, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeadsRow
	for rows.Next() {
		var i GetLeadsRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.CompanyID,
			&i.Position,
			&i.SocialLinks,
			&i.Birthday,
			&i.LastContact,
			&i.FirstContact,
			&i.FollowUp,
			&i.Source,
			&i.Notes,
			&i.LeadStatus,
			&i.PreferredContactMethod,
			&i.LeadScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchLeads = `-- name: SearchLeads :many
SELECT pid, first_name, last_name, email
FROM leads
WHERE (first_name ILIKE $1 OR last_name ILIKE $1 OR email ILIKE $1)
  AND owner_id = $2
ORDER BY last_name, first_name LIMIT $3
`

type SearchLeadsParams struct {
	FirstName string      `json:"first_name"`
	OwnerID   pgtype.Int4 `json:"owner_id"`
	Limit     int32       `json:"limit"`
}

type SearchLeadsRow struct {
	Pid       pgtype.UUID `json:"pid"`
	FirstName string      `json:"first_name"`
	LastName  string      `json:"last_name"`
	Email     pgtype.Text `json:"email"`
}

func (q *Queries) SearchLeads(ctx context.Context, arg SearchLeadsParams) ([]SearchLeadsRow, error) {
	rows, err := q.db.Query(ctx, searchLeads, arg.FirstName, arg.OwnerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchLeadsRow
	for rows.Next() {
		var i SearchLeadsRow
		if err := rows.Scan(
			&i.Pid,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLead = `-- name: UpdateLead :exec
UPDATE leads
SET first_name               = $1,
    last_name                = $2,
    email                    = $3,
    phone                    = $4,
    company_id               = $5,
    position                 = $6,
    social_links             = $7,
    birthday                 = $8,
    last_contact             = $9,
    first_contact            = $10,
    follow_up                = $11,
    source                   = $12,
    notes                    = $13,
    lead_status              = $14,
    preferred_contact_method = $15,
    lead_score               = $16,
    updated_at               = NOW()
WHERE pid = $17
  AND owner_id = $18
`

type UpdateLeadParams struct {
	FirstName              string           `json:"first_name"`
	LastName               string           `json:"last_name"`
	Email                  pgtype.Text      `json:"email"`
	Phone                  pgtype.Text      `json:"phone"`
	CompanyID              pgtype.Int4      `json:"company_id"`
	Position               pgtype.Text      `json:"position"`
	SocialLinks            []byte           `json:"social_links"`
	Birthday               pgtype.Date      `json:"birthday"`
	LastContact            pgtype.Timestamp `json:"last_contact"`
	FirstContact           pgtype.Timestamp `json:"first_contact"`
	FollowUp               pgtype.Timestamp `json:"follow_up"`
	Source                 pgtype.Text      `json:"source"`
	Notes                  pgtype.Text      `json:"notes"`
	LeadStatus             pgtype.Text      `json:"lead_status"`
	PreferredContactMethod pgtype.Text      `json:"preferred_contact_method"`
	LeadScore              pgtype.Int4      `json:"lead_score"`
	Pid                    pgtype.UUID      `json:"pid"`
	OwnerID                pgtype.Int4      `json:"owner_id"`
}

func (q *Queries) UpdateLead(ctx context.Context, arg UpdateLeadParams) error {
	_, err := q.db.Exec(ctx, updateLead,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.CompanyID,
		arg.Position,
		arg.SocialLinks,
		arg.Birthday,
		arg.LastContact,
		arg.FirstContact,
		arg.FollowUp,
		arg.Source,
		arg.Notes,
		arg.LeadStatus,
		arg.PreferredContactMethod,
		arg.LeadScore,
		arg.Pid,
		arg.OwnerID,
	)
	return err
}
