// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: campaign.sql

package pgdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCampaign = `-- name: CreateCampaign :one
INSERT INTO
    campaign(
        name,
        description,
        owner_id
    )
VALUES
    ($1, $2, $3)
RETURNING
    id,
    name,
    description,
    created_at,
    updated_at,
    is_active,
    is_processing
`

type CreateCampaignParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	OwnerID     pgtype.Int4 `json:"owner_id"`
}

type CreateCampaignRow struct {
	ID           int32            `json:"id"`
	Name         string           `json:"name"`
	Description  pgtype.Text      `json:"description"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	IsActive     bool             `json:"is_active"`
	IsProcessing bool             `json:"is_processing"`
}

func (q *Queries) CreateCampaign(ctx context.Context, arg CreateCampaignParams) (CreateCampaignRow, error) {
	row := q.db.QueryRow(ctx, createCampaign, arg.Name, arg.Description, arg.OwnerID)
	var i CreateCampaignRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.IsProcessing,
	)
	return i, err
}

const getCampaignByID = `-- name: GetCampaignByID :one
SELECT
    c.id,
    c.name,
    c.description,
    c.created_at,
    c.updated_at,
    c.is_active,
    c.is_processing,
    COUNT(r.id) as review_count
FROM
    campaign c
LEFT JOIN
    review r
ON
    c.id = r.campaign_id
WHERE
    c.id = $1
    AND
    c.owner_id = $2
GROUP BY
    c.id,
    c.name,
    c.description,
    c.created_at,
    c.updated_at,
    c.owner_id,
    c.is_active,
    c.is_processing
`

type GetCampaignByIDParams struct {
	ID      int32       `json:"id"`
	OwnerID pgtype.Int4 `json:"owner_id"`
}

type GetCampaignByIDRow struct {
	ID           int32            `json:"id"`
	Name         string           `json:"name"`
	Description  pgtype.Text      `json:"description"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	IsActive     bool             `json:"is_active"`
	IsProcessing bool             `json:"is_processing"`
	ReviewCount  int64            `json:"review_count"`
}

func (q *Queries) GetCampaignByID(ctx context.Context, arg GetCampaignByIDParams) (GetCampaignByIDRow, error) {
	row := q.db.QueryRow(ctx, getCampaignByID, arg.ID, arg.OwnerID)
	var i GetCampaignByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.IsProcessing,
		&i.ReviewCount,
	)
	return i, err
}

const getCampaigns = `-- name: GetCampaigns :many
SELECT
    c.id,
    c.name,
    c.description,
    c.created_at,
    c.updated_at,
    c.is_active,
    c.is_processing,
    COUNT(r.id) as review_count
FROM
    campaign c
LEFT JOIN
    review r
ON
    c.id = r.campaign_id
WHERE
    owner_id = $1
GROUP BY
    c.id,
    c.name,
    c.description,
    c.created_at,
    c.updated_at,
    c.owner_id,
    c.is_active,
    c.is_processing
`

type GetCampaignsRow struct {
	ID           int32            `json:"id"`
	Name         string           `json:"name"`
	Description  pgtype.Text      `json:"description"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	IsActive     bool             `json:"is_active"`
	IsProcessing bool             `json:"is_processing"`
	ReviewCount  int64            `json:"review_count"`
}

func (q *Queries) GetCampaigns(ctx context.Context, ownerID pgtype.Int4) ([]GetCampaignsRow, error) {
	rows, err := q.db.Query(ctx, getCampaigns, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCampaignsRow
	for rows.Next() {
		var i GetCampaignsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.IsProcessing,
			&i.ReviewCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsByCampaignID = `-- name: GetReviewsByCampaignID :many
SELECT
    r.id,
    r.campaign_id,
    r.sentiment,
    r.review,
    r.created_at,
    r.updated_at
FROM
    review r
WHERE
    r.campaign_id = $1
`

func (q *Queries) GetReviewsByCampaignID(ctx context.Context, campaignID int32) ([]Review, error) {
	rows, err := q.db.Query(ctx, getReviewsByCampaignID, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Sentiment,
			&i.Review,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSentimentCountByCampaignID = `-- name: GetSentimentCountByCampaignID :one
SELECT
    COUNT(r.id) as positive_count
FROM
    review r
WHERE
    r.campaign_id = $1
    AND
    r.sentiment = $2
`

type GetSentimentCountByCampaignIDParams struct {
	CampaignID int32  `json:"campaign_id"`
	Sentiment  string `json:"sentiment"`
}

func (q *Queries) GetSentimentCountByCampaignID(ctx context.Context, arg GetSentimentCountByCampaignIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, getSentimentCountByCampaignID, arg.CampaignID, arg.Sentiment)
	var positive_count int64
	err := row.Scan(&positive_count)
	return positive_count, err
}
